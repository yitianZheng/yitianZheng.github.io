<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>无所事事刷anyview的日子（chapter 01~02） | yitian&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="好久没更博了，实在是很懒了。开学后都没怎么看前端的知识，把主要精力都放在课程上了。主要是大二觉得课程变难变多，也想好好学。还有的想法是，先把学习弄好，然后之后才能留出更多精力来忙其他的事情。事情总会一件一件一件一件一件一件一件一件一件一件慢慢做完的…… 最近都在抓紧时间看数据结构，感觉大二老师讲的都很快很乱，都要自学了= =。数据结构感觉是培养一种编程思维，对思维的锻炼很有帮助。一边看书一边刷an">
<meta property="og:type" content="article">
<meta property="og:title" content="无所事事刷anyview的日子（chapter 01~02）">
<meta property="og:url" content="http://yoursite.com/2017/09/21/被anyview支配的恐惧/index.html">
<meta property="og:site_name" content="yitian&#39;s blog">
<meta property="og:description" content="好久没更博了，实在是很懒了。开学后都没怎么看前端的知识，把主要精力都放在课程上了。主要是大二觉得课程变难变多，也想好好学。还有的想法是，先把学习弄好，然后之后才能留出更多精力来忙其他的事情。事情总会一件一件一件一件一件一件一件一件一件一件慢慢做完的…… 最近都在抓紧时间看数据结构，感觉大二老师讲的都很快很乱，都要自学了= =。数据结构感觉是培养一种编程思维，对思维的锻炼很有帮助。一边看书一边刷an">
<meta property="og:updated_time" content="2017-09-24T13:21:17.717Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="无所事事刷anyview的日子（chapter 01~02）">
<meta name="twitter:description" content="好久没更博了，实在是很懒了。开学后都没怎么看前端的知识，把主要精力都放在课程上了。主要是大二觉得课程变难变多，也想好好学。还有的想法是，先把学习弄好，然后之后才能留出更多精力来忙其他的事情。事情总会一件一件一件一件一件一件一件一件一件一件慢慢做完的…… 最近都在抓紧时间看数据结构，感觉大二老师讲的都很快很乱，都要自学了= =。数据结构感觉是培养一种编程思维，对思维的锻炼很有帮助。一边看书一边刷an">
  
    <link rel="alternate" href="/atom.xml" title="yitian&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">yitian&#39;s blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">along the road</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-被anyview支配的恐惧" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/09/21/被anyview支配的恐惧/" class="article-date">
  <time datetime="2017-09-21T14:21:06.000Z" itemprop="datePublished">2017-09-21</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      无所事事刷anyview的日子（chapter 01~02）
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>好久没更博了，实在是很懒了。开学后都没怎么看前端的知识，把主要精力都放在课程上了。主要是大二觉得课程变难变多，也想好好学。还有的想法是，先把学习弄好，然后之后才能留出更多精力来忙其他的事情。事情总会一件一件一件一件一件一件一件一件一件一件慢慢做完的……</p>
<p>最近都在抓紧时间看数据结构，感觉大二老师讲的都很快很乱，都要自学了= =。数据结构感觉是培养一种编程思维，对思维的锻炼很有帮助。一边看书一边刷anyview，还是学得比较快的。<br><a id="more"></a></p>
<h2 id="DC01"><a href="#DC01" class="headerlink" title="DC01"></a>DC01</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/**********</div><div class="line">【题目】已知k阶裴波那契序列的定义为</div><div class="line">    f(0)=0, f(1)=0, ..., f(k-2)=0, f(k-1)=1;</div><div class="line">    f(n)=f(n-1)+f(n-2)+...+f(n-k), n=k,k+1,...</div><div class="line">试编写求k阶裴波那契序列的第m项值的函数算法，</div><div class="line">k和m均以值调用的形式在函数参数表中出现。</div><div class="line">**********/</div><div class="line">Status Fibonacci(int k, int m, int &amp;f) </div><div class="line">/* 求k阶斐波那契序列的第m项的值f */</div><div class="line">&#123;  </div><div class="line">    int a[60],sum,i,j;</div><div class="line">    if(k&lt;2||m&lt;0) return ERROR;  /*k&lt;2为负*/</div><div class="line">    if(m&lt;k-1) f=0; /*前k-1项均为0*/</div><div class="line">    else if(m==k) f=1;</div><div class="line">    else &#123;</div><div class="line">      for(i=0;i&lt;=k-2;i++)&#123;</div><div class="line">        a[i]=0;</div><div class="line">        a[k-1]=1;</div><div class="line">        for(i=k;i&lt;=m;i++)&#123;</div><div class="line">            sum=0;  /*置0*/</div><div class="line">            for(j=i-k;j&lt;i;j++) sum+=a[j];</div><div class="line">            a[i]=sum;</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">      f=a[m];</div><div class="line">    &#125;</div><div class="line">    return OK;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**********</div><div class="line">【题目】试写一算法，由长度为n的一维数组a构建一个序列S。</div><div class="line">序列的类型定义为：</div><div class="line">typedef struct &#123;</div><div class="line">  ElemType  *elem;</div><div class="line">  int  length;</div><div class="line">&#125; Sequence;</div><div class="line">***********/</div><div class="line">Status CreateSequence(Sequence &amp;S, int n, ElemType *a) </div><div class="line">/* 由长度为n的一维数组a构建一个序列S，并返回OK。 */</div><div class="line">/* 若构建失败，则返回ERROR                       */</div><div class="line">&#123;</div><div class="line">    int i;</div><div class="line">    S.elem=(ElemType*)malloc(n*sizeof(ElemType)); /*分配n个元素空间*/</div><div class="line">    if(S.elem==NULL||n&lt;=0) return ERROR;  /*空间分配不成功或参数错误*/</div><div class="line">    else &#123;</div><div class="line">        S.length=n;</div><div class="line">        for(i=0;i&lt;n;i++) &#123;</div><div class="line">            S.elem[i]=*(a+i);</div><div class="line">        &#125;</div><div class="line">        return OK;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="DC02"><a href="#DC02" class="headerlink" title="DC02"></a>DC02</h2><p>1、顺序栈<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">/**********</div><div class="line">【题目】若顺序栈的类型重新定义如下。试编写算法，</div><div class="line">构建初始容量和扩容增量分别为size和inc的空顺序栈S。</div><div class="line">typedef struct &#123;</div><div class="line">  ElemType *elem; // 存储空间的基址</div><div class="line">  ElemType *top;  // 栈顶元素的下一个位置</div><div class="line">  int size;       // 当前分配的存储容量</div><div class="line">  int increment;  // 扩容时，增加的存储容量</div><div class="line">&#125; SqStack2;</div><div class="line">***********/</div><div class="line">Status InitStack_Sq2(SqStack2 &amp;S, int size, int inc)</div><div class="line">/* 构建初始容量和扩容增量分别为size和inc的空顺序栈S。*/ </div><div class="line">/* 若成功，则返回OK；否则返回ERROR。                 */</div><div class="line">&#123;</div><div class="line">    S.elem=(ElemType*)malloc(sizeof(ElemType));</div><div class="line">    if(S.elem==NULL||size&lt;=0||inc&lt;=0) return ERROR;</div><div class="line">    else &#123;</div><div class="line">        S.top=S.elem;</div><div class="line">        S.size=size;</div><div class="line">        S.increment=inc;</div><div class="line">        return OK;</div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>2、循环队列：注意，规定当 Q.rear==maxSize-1/Q.front==maxSize-1时，Q.rear/Q.front置0。<br>合并两种情况，即：Q.rear=(Q.rear+1)%maxSize/Q.front=(Q.front+1)%maxSize，循环加一。<br>所以 Q.front==Q.rear 不能判断队列状态是”空”还是”满”。<br>可以用三种方法：<br>1）设一标志域标识队列的空与满。<br>2）设一个长度域记录队列中元素的个数。<br>3）少用一个元素空间，即 Q.front==(Q.rear+1)%maxSize 为队满。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line">/**********</div><div class="line">【题目】如果希望循环队列中的元素都能得到利用，</div><div class="line">则可设置一个标志域tag，并以tag值为0或1来区分尾</div><div class="line">指针和头指针值相同时的队列状态是&quot;空&quot;还是&quot;满&quot;。</div><div class="line">试编写与此结构相应的入队列和出队列的算法。</div><div class="line">本题的循环队列CTagQueue的类型定义如下：</div><div class="line">typedef struct &#123;</div><div class="line">  ElemType elem[MAXQSIZE];</div><div class="line">  int tag;</div><div class="line">  int front;</div><div class="line">  int rear;</div><div class="line">&#125; CTagQueue;</div><div class="line">**********/</div><div class="line">Status EnCQueue(CTagQueue &amp;Q, ElemType x)</div><div class="line">/* 将元素x加入队列Q，并返回OK；*/</div><div class="line">/* 若失败，则返回ERROR。       */</div><div class="line">&#123;</div><div class="line">    if(Q.front==Q.rear&amp;&amp;Q.tag==1) return ERROR;</div><div class="line">    else &#123;</div><div class="line">        Q.elem[Q.rear++]=x;</div><div class="line">        return OK;</div><div class="line">    &#125;    </div><div class="line">&#125;</div><div class="line"></div><div class="line">Status DeCQueue(CTagQueue &amp;Q, ElemType &amp;x)</div><div class="line">/* 将队列Q的队头元素退队到x，并返回OK；*/</div><div class="line">/* 若失败，则返回ERROR。               */</div><div class="line">&#123;</div><div class="line">    if(Q.front==Q.rear&amp;&amp;Q.tag==0) return ERROR;</div><div class="line">    else &#123;</div><div class="line">        x=Q.elem[Q.front++];</div><div class="line">        Q.tag=0;</div><div class="line">        return OK;</div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">/**********</div><div class="line">【题目】假设将循环队列定义为：以域变量rear</div><div class="line">和length分别指示循环队列中队尾元素的位置和内</div><div class="line">含元素的个数。试给出此循环队列的队满条件，并</div><div class="line">写出相应的入队列和出队列的算法（在出队列的算</div><div class="line">法中要返回队头元素）。</div><div class="line">本题的循环队列CLenQueue的类型定义如下：</div><div class="line">typedef struct &#123;</div><div class="line">  ElemType elem[MAXQSIZE];</div><div class="line">  int length;</div><div class="line">  int rear;</div><div class="line">&#125; CLenQueue;</div><div class="line">**********/</div><div class="line">Status EnCQueue(CLenQueue &amp;Q, ElemType x)</div><div class="line">  /* 将元素x加入队列Q，并返回OK；*/</div><div class="line">  /* 若失败，则返回ERROR。       */</div><div class="line">&#123;</div><div class="line">    if(Q.length==MAXQSIZE) return ERROR;</div><div class="line">    else &#123; </div><div class="line">        Q.rear=(Q.rear+1)%MAXQSIZE;</div><div class="line">        Q.elem[Q.rear]=x;        </div><div class="line">        Q.length++;</div><div class="line">        return OK;</div><div class="line">    &#125;    </div><div class="line">&#125;</div><div class="line">Status DeCQueue(CLenQueue &amp;Q, ElemType &amp;x)</div><div class="line">  /* 将队列Q的队头元素退队到x，并返回OK；*/</div><div class="line">  /* 若失败，则返回ERROR。               */</div><div class="line">&#123;</div><div class="line">    if(Q.length==0) return ERROR;</div><div class="line">    else &#123;</div><div class="line">        x=Q.elem[(Q.rear+MAXQSIZE-Q.length+1)%MAXQSIZE];</div><div class="line">        Q.length--;</div><div class="line">        return OK;</div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3、顺序表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">/**********</div><div class="line">【题目】假设有两个集合A和B分别用两个线性表LA和LB</div><div class="line">表示(即：线性表中的数据元素即为集合中的成员），</div><div class="line">试写一算法，求并集A＝A∪B。</div><div class="line">顺序表类型定义如下</div><div class="line">typedef struct &#123;</div><div class="line">  ElemType *elem;     // 存储空间的基址</div><div class="line">  int length;    // 当前长度</div><div class="line">  int size;      // 存储容量 </div><div class="line">  int increment; // 空间不够增加空间大小</div><div class="line">&#125; SqList;  // 顺序表</div><div class="line">可调用顺序表的以下接口函数：   </div><div class="line">Status InitList_Sq(SqList &amp;L, int size, int inc); // 初始化顺序表L</div><div class="line">int ListLength_Sq(SqList L);  // 返回顺序表L中元素个数</div><div class="line">Status GetElem_Sq(SqList L, int i, ElemType &amp;e); </div><div class="line">// 用e返回顺序表L中第i个元素的值</div><div class="line">int Search_Sq(SqList L, ElemType e); </div><div class="line">// 在顺序表L顺序查找元素e，成功时返回该元素在表中第一次出现的位置，否则返回-1</div><div class="line">Status Append_Sq(SqList &amp;L, ElemType e);  // 在顺序表L表尾添加元素e</div><div class="line">**********/</div><div class="line">void Union(SqList &amp;La, SqList Lb)</div><div class="line">&#123;    </div><div class="line">    int i;</div><div class="line">    ElemType elem=&apos;a&apos;;</div><div class="line">    for(i=0;i&lt;Lb.length;i++) &#123;</div><div class="line">       elem=Lb.elem[i];</div><div class="line">       if(Search_Sq(La,elem)==-1) &#123;</div><div class="line">             if(La.length&gt;=La.size) &#123;</div><div class="line">                 ElemType *newbase;</div><div class="line">                 newbase=(ElemType*)realloc(La.elem,(La.size+La.increment)*sizeof(ElemType));</div><div class="line">                 if(newbase==NULL) return;</div><div class="line">                 La.size=La.size+La.increment;</div><div class="line">                 La.elem=newbase;</div><div class="line">             &#125;</div><div class="line">             Append_Sq(La,elem);                </div><div class="line">         &#125;</div><div class="line">    &#125;</div><div class="line">        </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>4、链栈<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">/**********</div><div class="line">【题目】试写一算法，实现链栈的取栈顶元素操作。</div><div class="line">链栈的类型定义为：</div><div class="line">typedef struct LSNode &#123;</div><div class="line">  ElemType data;       // 数据域</div><div class="line">  struct LSNode *next; // 指针域</div><div class="line">&#125; LSNode, *LStack;    // 结点和链栈类型</div><div class="line">***********/</div><div class="line">Status GetTop_L(LStack S, ElemType &amp;e) </div><div class="line">/* 取链栈S的栈顶元素到e，并返回OK; */</div><div class="line">/* 若S是空栈，则失败，返回ERROR。  */</div><div class="line">&#123;</div><div class="line">    if(S==NULL) return ERROR;</div><div class="line">    else &#123;</div><div class="line">        e=S-&gt;data;</div><div class="line">        return OK;</div><div class="line">    &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>5、链队列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">/**********</div><div class="line">【题目】试写一算法，实现链队列的求队列长度操作。</div><div class="line">链队列的类型定义为：</div><div class="line">typedef struct LQNode &#123;     </div><div class="line">  ElemType  data;  </div><div class="line">  struct LQNode  *next;  </div><div class="line">&#125; LQNode, *QueuePtr; // 结点和结点指针类型</div><div class="line">typedef struct &#123;     </div><div class="line">  QueuePtr  front;  // 队头指针</div><div class="line">  QueuePtr  rear;   // 队尾指针</div><div class="line">&#125; LQueue;  // 链队列类型</div><div class="line">***********/</div><div class="line">int QueueLength_LQ(LQueue Q)</div><div class="line">/* 求链队列Q的长度并返回其值 */</div><div class="line">&#123;</div><div class="line">    int i=1;</div><div class="line">    if(Q.front==NULL) return 0;</div><div class="line">    else &#123;</div><div class="line">        LQNode *p;</div><div class="line">        p=Q.front;</div><div class="line">        while(p-&gt;next!=NULL) &#123;</div><div class="line">            i++;</div><div class="line">            p=p-&gt;next;</div><div class="line">        &#125;</div><div class="line">        return i;</div><div class="line">    &#125;      </div><div class="line">&#125;</div><div class="line">```  </div><div class="line">6、带头结点的单链表</div></pre></td></tr></table></figure></p>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，实现带头结点单链表的清空操作。</p>
<p>单链表的类型定义为：<br>typedef struct LNode {<br>  ElemType  data;<br>  struct LNode  <em>next;<br>} LNode, </em>LinkList; // 结点和结点指针类型<br><strong><strong><em>*</em></strong></strong>/<br>Status ClearList_L(LinkList &amp;L)<br>/<em> 将带头结点单链表L置为空表，并返回OK。</em>/<br>/<em> 若L不是带头结点单链表，则返回ERROR。 </em>/<br>{<br>    LinkList p;<br>    p=L-&gt;next;<br>    if(L==NULL) return ERROR;<br>    else {<br>        while(p!=NULL) {<br>            L-&gt;next=p-&gt;next;<br>            free(p);<br>            p=L-&gt;next;<br>        }<br>        return OK;<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，在带头结点单链表L插入第i元素e。<br>带头结点单链表的类型定义为：<br>typedef struct LNode {<br>  ElemType      data;<br>  struct LNode <em>next;<br>} LNode, </em>LinkList;<br><strong><strong>**</strong></strong>/<br>Status Insert_L(LinkList L, int i, ElemType e)<br>/<em> 在带头结点单链表L插入第i元素e，并返回OK。</em>/<br>/<em> 若参数不合理，则返回ERROR。              </em>/<br>{<br>    int k=0;<br>    LNode <em>p=L,</em>q;<br>    while(p&amp;&amp;k<i-1) {="" p="p-">next;<br>        k++;<br>     }<br>    if(!p||k&gt;i-1) return ERROR;<br>    q=(LinkList)malloc(sizeof(LNode));<br>    q-&gt;data=e;<br>    q-&gt;next=p-&gt;next;<br>    p-&gt;next=q;<br>    return OK;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></i-1)></p>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，在带头结点单链表删除第i元素到e。<br>带头结点单链表的类型定义为：<br>typedef struct LNode {<br>  ElemType      data;<br>  struct LNode <em>next;<br>} LNode, </em>LinkList;<br><strong><strong>**</strong></strong>/<br>Status Delete_L(LinkList L, int i, ElemType &amp;e)<br>/<em> 在带头结点单链表L删除第i元素到e，并返回OK。</em>/<br>/<em> 若参数不合理，则返回ERROR。                </em>/<br>{<br>    int j=0;<br>    LinkList p=L,q;<br>    while(p-&gt;next&amp;&amp;j<i-1) {="" p="p-">next;<br>        j++;<br>    }<br>   if(!p-&gt;next||j&gt;i-1) return ERROR;<br>   q=p-&gt;next;<br>   p-&gt;next=q-&gt;next;<br>   e=q-&gt;data;<br>   free(q);<br>   return OK;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></i-1)></p>
<p>/<strong><strong>**</strong></strong><br>【题目】试写一算法，在带头结点单链表的第i元素起的<br>所有元素从链表移除，并构成一个带头结点的新链表。<br>带头结点单链表的类型定义为：<br>typedef struct LNode {<br>  ElemType      data;<br>  struct LNode <em>next;<br>} LNode, </em>LinkList;<br><strong><strong>**</strong></strong>/<br>Status Split_L(LinkList L, LinkList &amp;Li, int i)<br>/<em> 在带头结点单链表L的第i元素起的所有元素 </em>/<br>/<em> 移除，并构成带头结点链表Li，返回OK。   </em>/<br>/<em> 若参数不合理，则Li为NULL，返回ERROR。  </em>/<br>{<br>    int j;<br>    LinkList p,t=L;<br>    Li=(LNode*)malloc(sizeof(LNode));<br>    if(Li==NULL) return ERROR;<br>    if(i&lt;=0) {<br>        Li=NULL;<br>        return ERROR;<br>    }<br>    if(L==NULL||L-&gt;next==NULL) {<br>        Li=NULL;<br>        return ERROR;<br>    }<br>    for(j=1;j<i;j++) {="" t="t-">next;<br>        if(t-&gt;next==NULL) {<br>            Li=NULL;<br>            return ERROR;<br>        }<br>    }<br>    p=t-&gt;next;<br>    t-&gt;next=NULL;<br>    Li-&gt;next=p;<br>    return OK;<br>}<br>```</i;j++)></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/09/21/被anyview支配的恐惧/" data-id="cj7yrwydv000oisuh9olirgzn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/09/24/无所事事刷anyview的日子（chapter-03-04）/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          无所事事刷anyview的日子（chapter 03~04）
        
      </div>
    </a>
  
  
    <a href="/2017/08/11/Night-s-Watch暑期培训总结/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Night&#39;s Watch暑期培训总结</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/09/">九月 2017</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/08/">八月 2017</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/07/">七月 2017</a><span class="archive-list-count">24</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/09/24/无所事事刷anyview的日子（chapter-03-04）/">无所事事刷anyview的日子（chapter 03~04）</a>
          </li>
        
          <li>
            <a href="/2017/09/21/被anyview支配的恐惧/">无所事事刷anyview的日子（chapter 01~02）</a>
          </li>
        
          <li>
            <a href="/2017/08/11/Night-s-Watch暑期培训总结/">Night&#39;s Watch暑期培训总结</a>
          </li>
        
          <li>
            <a href="/2017/07/27/ES6之模板字符串/">ES6之模板字符串</a>
          </li>
        
          <li>
            <a href="/2017/07/26/JS之数据类型转化/">JS之数据类型转化</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 yitianZheng<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>